netstat -ano | findstr :8080

taskkill /PID 6292 /F


Awesome! Letâ€™s start step by step.

### **ðŸ›  Step 1: Setup & Project Structure**
Before diving into coding, we need to set up a clean project structure for microservices. Here's how weâ€™ll proceed:

---

### **ðŸ”¹ First Task: Setup Transaction Service (Spring Boot)**
This will be our first microservice that will:
âœ… Accept user transactions via REST API
âœ… Store transactions in PostgreSQL
âœ… Send events to Kafka

#### **ðŸ“Œ Step 1.1: Setup Spring Boot Project**
1. **Create a new Spring Boot project** using [Spring Initializr](https://start.spring.io/) with the following dependencies:
   - Spring Web
   - Spring Boot DevTools
   - Spring Data JPA
   - PostgreSQL Driver
   - Spring Kafka (for event streaming)

2. **Project Structure:**
   ```
   transaction-service/
   â”œâ”€â”€ src/main/java/com/example/transaction
   â”‚   â”œâ”€â”€ controller/   -> Exposes REST API
   â”‚   â”œâ”€â”€ service/      -> Business logic
   â”‚   â”œâ”€â”€ repository/   -> Database layer
   â”‚   â”œâ”€â”€ model/        -> Transaction entity
   â”‚   â”œâ”€â”€ config/       -> Kafka & DB configurations
   â”œâ”€â”€ src/main/resources/
   â”‚   â”œâ”€â”€ application.yml
   â”œâ”€â”€ pom.xml
   â”œâ”€â”€ README.md
   ```

---

### **ðŸ”¹ Step 1.2: Configure PostgreSQL**
1. Install PostgreSQL and create a database:
   ```sql
   CREATE DATABASE transaction_db;
   ```
2. Add **PostgreSQL config** in `application.yml`:
   ```yaml
   spring:
     datasource:
       url: jdbc:postgresql://localhost:5432/transaction_db
       username: postgres
       password: yourpassword
     jpa:
       hibernate:
         ddl-auto: update
       show-sql: true
   ```

---

### **ðŸ”¹ Step 1.3: Create the Transaction Entity**
```java
@Entity
@Table(name = "transactions")
public class Transaction {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String userId;
    private Double amount;
    private String type; // CREDIT or DEBIT
    private LocalDateTime timestamp;

    // Getters and Setters
}
```

---

### **ðŸ”¹ Step 1.4: Create Repository Layer**
```java
@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    List<Transaction> findByUserId(String userId);
}
```

---

### **ðŸ”¹ Step 1.5: Create REST API Controller**
```java
@RestController
@RequestMapping("/transactions")
public class TransactionController {

    @Autowired
    private TransactionRepository transactionRepository;

    @PostMapping
    public ResponseEntity<Transaction> createTransaction(@RequestBody Transaction transaction) {
        transaction.setTimestamp(LocalDateTime.now());
        Transaction savedTransaction = transactionRepository.save(transaction);
        return ResponseEntity.ok(savedTransaction);
    }

    @GetMapping("/{userId}")
    public ResponseEntity<List<Transaction>> getTransactions(@PathVariable String userId) {
        return ResponseEntity.ok(transactionRepository.findByUserId(userId));
    }
}
```

---

### **ðŸ”¹ Step 1.6: Run the Application & Test APIs**
1. **Run the Spring Boot app**
   ```sh
   mvn spring-boot:run
   ```
2. **Test API using Postman or cURL:**
   - **Create a transaction:**
     ```json
     POST http://localhost:8080/transactions
     {
       "userId": "user123",
       "amount": 1000,
       "type": "CREDIT"
     }
     ```
   - **Fetch transactions for a user:**
     ```
     GET http://localhost:8080/transactions/user123
     ```

---

### **ðŸ”¹ Next Steps**
âœ… If this is working fine, the next step will be integrating **Kafka** to send transaction events. Let me know once you complete this part! ðŸš€